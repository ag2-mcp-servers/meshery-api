# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T05:06:20+00:00

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, RootModel


class AlertEvaluator(BaseModel):
    params: Optional[List[float]] = None
    type: Optional[str] = None


class AlertNotification(BaseModel):
    disableResolveMessage: Optional[bool] = None
    frequency: Optional[str] = None
    id: Optional[int] = None
    isDefault: Optional[bool] = None
    name: Optional[str] = None
    sendReminder: Optional[bool] = None
    settings: Optional[Dict[str, Any]] = None
    type: Optional[str] = None
    uid: Optional[str] = None


class AlertOperator(BaseModel):
    type: Optional[str] = None


class AlertQuery(BaseModel):
    params: Optional[List[str]] = None


class AlertReducer(BaseModel):
    params: Optional[List[str]] = None
    type: Optional[str] = None


class AuthenticateOKBody(BaseModel):
    IdentityToken: str = Field(
        ...,
        description='An opaque token used to authenticate a user after a successful login',
    )
    Status: str = Field(..., description='The status of the authentication')


class BoolString(BaseModel):
    Flag: Optional[bool] = None
    Value: Optional[str] = None


class ClientIPConfig(BaseModel):
    timeoutSeconds: Optional[int] = Field(
        None,
        description='timeoutSeconds specifies the seconds of ClientIP type session sticky time.\nThe value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".\nDefault value is 10800(for 3 hours).\n+optional',
    )


class Column(BaseModel):
    text: Optional[str] = None
    value: Optional[str] = None


class ContainerChangeResponseItem(BaseModel):
    Kind: int = Field(..., description='Kind of change')
    Path: str = Field(..., description='Path to file that has changed')


class ContainerCreateCreatedBody(BaseModel):
    Id: str = Field(..., description='The ID of the created container')
    Warnings: List[str] = Field(
        ..., description='Warnings encountered when creating the container'
    )


class ContainerTopOKBody(BaseModel):
    Processes: List[List[str]] = Field(
        ...,
        description='Each process running in the container, where each is process is an array of values corresponding to the titles',
    )
    Titles: List[str] = Field(..., description='The ps column titles')


class ContainerUpdateOKBody(BaseModel):
    Warnings: List[str] = Field(..., description='warnings')


class ContainerWaitOKBodyError(BaseModel):
    Message: Optional[str] = Field(None, description='Details of an error')


class ErrorResponse(BaseModel):
    message: str = Field(..., description='The error message.')


class Feature(RootModel[str]):
    root: str = Field(
        ..., description='Feature is a type to store the features of the provider'
    )


class Step(BaseModel):
    color: Optional[str] = None
    value: Optional[str] = None


class Threshold(BaseModel):
    mode: Optional[str] = None
    steps: Optional[List[Step]] = None


class Defaults(BaseModel):
    threshold: Optional[Threshold] = None
    unit: Optional[str] = None


class FieldConfig(BaseModel):
    defaults: Optional[Defaults] = None


class FieldsV1(BaseModel):
    pass


class FloatString(BaseModel):
    Valid: Optional[bool] = None
    Value: Optional[float] = None


class Gauge(BaseModel):
    maxValue: Optional[float] = None
    minValue: Optional[float] = None
    show: Optional[bool] = None
    thresholdLabels: Optional[bool] = None
    thresholdMarkers: Optional[bool] = None


class GrafanaConfigParams(BaseModel):
    grafanaAPIKey: Optional[str] = None
    grafanaURL: Optional[str] = None


class GrafanaDataSource(BaseModel):
    id: Optional[int] = None
    name: Optional[str] = None


class GrafanaTemplateVars(BaseModel):
    datasource: Optional[GrafanaDataSource] = None
    hide: Optional[int] = None
    name: Optional[str] = None
    query: Optional[str] = None
    value: Optional[Dict[str, Any]] = None


class GraphDriverData(BaseModel):
    Data: Dict[str, str] = Field(..., description='data')
    Name: str = Field(..., description='name')


class GraphQLExtension(BaseModel):
    component: Optional[str] = None
    path: Optional[str] = None


class GraphQLExtensions(RootModel[List[GraphQLExtension]]):
    root: List[GraphQLExtension] = Field(
        ...,
        description='GraphQLExtensions is a collection of GraphQLExtension endpoints',
    )


class HistoryResponseItem(BaseModel):
    Comment: str = Field(..., description='comment')
    Created: int = Field(..., description='created')
    CreatedBy: str = Field(..., description='created by')
    Id: str = Field(..., description='Id')
    Size: int = Field(..., description='size')
    Tags: List[str] = Field(..., description='tags')


class Href(BaseModel):
    external: Optional[bool] = None
    uri: Optional[str] = None


class IPFamily(RootModel[str]):
    root: str = Field(
        ...,
        description='IPFamily represents the IP Family (IPv4 or IPv6). This type is used\nto express the family of an IP expressed by a type (i.e. service.Spec.IPFamily)',
    )


class IdResponse(BaseModel):
    Id: str = Field(..., description='The id of the newly created object.')


class ImageDeleteResponseItem(BaseModel):
    Deleted: Optional[str] = Field(
        None, description='The image ID of an image that was deleted'
    )
    Untagged: Optional[str] = Field(
        None, description='The image ID of an image that was untagged'
    )


class ImageSummary(BaseModel):
    Containers: int = Field(..., description='containers')
    Created: int = Field(..., description='created')
    Id: str = Field(..., description='Id')
    Labels: Dict[str, str] = Field(..., description='labels')
    ParentId: str = Field(..., description='parent Id')
    RepoDigests: List[str] = Field(..., description='repo digests')
    RepoTags: List[str] = Field(..., description='repo tags')
    SharedSize: int = Field(..., description='shared size')
    Size: int = Field(..., description='size')
    VirtualSize: int = Field(..., description='virtual size')


class IntString(BaseModel):
    Valid: Optional[bool] = None
    Value: Optional[int] = None


class K8SContext(BaseModel):
    clusterName: Optional[str] = None
    contextName: Optional[str] = None
    currentContext: Optional[bool] = Field(
        None, description='ContextDisplayName string `json:"context-display-name"`'
    )


class K8SNode(BaseModel):
    allocatable_cpu: Optional[str] = None
    allocatable_memory: Optional[str] = None
    architecture: Optional[str] = None
    capacity_cpu: Optional[str] = None
    capacity_memory: Optional[str] = None
    container_runtime_version: Optional[str] = None
    hostname: Optional[str] = None
    internal_ip: Optional[str] = None
    kubelet_version: Optional[str] = None
    kubeproxy_version: Optional[str] = None
    operating_system: Optional[str] = None
    os_image: Optional[str] = None


class LatenciesMs(BaseModel):
    Average: Optional[float] = None
    Max: Optional[float] = None
    Min: Optional[float] = None
    P50: Optional[float] = None
    P90: Optional[float] = None
    P99: Optional[float] = None


class Legend(BaseModel):
    alignAsTable: Optional[bool] = None
    avg: Optional[bool] = None
    current: Optional[bool] = None
    hideEmpty: Optional[bool] = None
    hideZero: Optional[bool] = None
    max: Optional[bool] = None
    min: Optional[bool] = None
    rightSide: Optional[bool] = None
    show: Optional[bool] = None
    sideWidth: Optional[int] = None
    total: Optional[bool] = None
    values: Optional[bool] = None


class Link(BaseModel):
    asDropdown: Optional[bool] = None
    dashUri: Optional[str] = None
    dashboard: Optional[str] = None
    icon: Optional[str] = None
    includeVars: Optional[bool] = None
    keepTime: Optional[bool] = None
    params: Optional[str] = None
    tags: Optional[List[str]] = None
    targetBlank: Optional[bool] = None
    title: Optional[str] = None
    tooltip: Optional[str] = None
    type: Optional[str] = None
    url: Optional[str] = None


class LoadBalancerIngress(BaseModel):
    hostname: Optional[str] = Field(
        None,
        description='Hostname is set for load-balancer ingress points that are DNS based\n(typically AWS load-balancers)\n+optional',
    )
    ip: Optional[str] = Field(
        None,
        description='IP is set for load-balancer ingress points that are IP based\n(typically GCE or OpenStack load-balancers)\n+optional',
    )


class LoadBalancerStatus(BaseModel):
    ingress: Optional[List[LoadBalancerIngress]] = Field(
        None,
        description='Ingress is a list containing ingress points for the load-balancer.\nTraffic intended for the service should be sent to these ingress points.\n+optional',
    )


class LoadTestPreferences(BaseModel):
    c: Optional[int] = None
    gen: Optional[str] = None
    qps: Optional[int] = None
    t: Optional[str] = None


class ManagedFieldsOperationType(RootModel[str]):
    root: str = Field(
        ...,
        title='ManagedFieldsOperationType is the type of operation which lead to a ManagedFieldsEntry being created.',
    )


class Map(RootModel[Optional[Dict[str, Dict[str, Any]]]]):
    root: Optional[Dict[str, Dict[str, Any]]] = None


class MapType(BaseModel):
    name: Optional[str] = None
    value: Optional[int] = None


class OpCategory(RootModel[int]):
    root: int


class ReduceOptions(BaseModel):
    calcs: Optional[List[str]] = None
    fields: Optional[str] = None
    values: Optional[bool] = None


class Options(BaseModel):
    colorMode: Optional[str] = None
    content: Optional[str] = None
    displayMode: Optional[str] = None
    graphMode: Optional[str] = None
    justifyMode: Optional[str] = None
    mode: Optional[str] = None
    orientation: Optional[str] = None
    reduceOptions: Optional[ReduceOptions] = None
    textMode: Optional[str] = None


class Cards(BaseModel):
    cardPadding: Optional[float] = None
    cardRound: Optional[float] = None


class Color(BaseModel):
    cardColor: Optional[str] = None
    colorScale: Optional[str] = None
    colorScheme: Optional[str] = None
    exponent: Optional[float] = None
    max: Optional[float] = None
    min: Optional[float] = None
    mode: Optional[str] = None


class GridPos(BaseModel):
    h: Optional[int] = None
    w: Optional[int] = None
    x: Optional[int] = None
    y: Optional[int] = None


class ScopedVars(BaseModel):
    selected: Optional[bool] = None
    text: Optional[str] = None
    value: Optional[str] = None


class XAxis(BaseModel):
    show: Optional[bool] = None


class YAxis(BaseModel):
    decimals: Optional[int] = None
    format: Optional[str] = None
    logBase: Optional[int] = None
    max: Optional[str] = None
    min: Optional[str] = None
    show: Optional[bool] = None
    splitFactor: Optional[float] = None


class PerformanceProfileParameters(BaseModel):
    concurrent_request: Optional[int] = Field(
        None, description='number of concurrent requests'
    )
    duration: Optional[str] = Field(None, description='duration of tests e.g. 30s')
    endpoints: Optional[List[str]] = Field(
        None, description='array of urls of performance results'
    )
    load_generators: Optional[List[str]] = Field(
        None, description='array of load generators'
    )
    name: Optional[str] = Field(None, description='name of performance profile')
    qps: Optional[int] = Field(None, description='qps in integer')
    service_mesh: Optional[str] = Field(
        None, description='service mesh for performance tests'
    )


class PerformanceSpec(BaseModel):
    ActualQPS: Optional[float] = None
    DetailsURI: Optional[str] = None
    EndTime: Optional[datetime] = None
    EnvID: Optional[str] = None
    Latencies: Optional[LatenciesMs] = None
    MeshConfigID: Optional[str] = None
    SMPVersion: Optional[str] = None
    StartTime: Optional[datetime] = None
    TestID: Optional[str] = None


class PerformanceTestConfigClientProtocol(RootModel[int]):
    root: int


class PerformanceTestParameters(BaseModel):
    c: Optional[int] = Field(None, description='concurrent request in number')
    dur: Optional[str] = Field(None, description='duration e.g. s for second')
    loadGenerator: Optional[str] = Field(
        None, description='load generator for performance test'
    )
    mesh: Optional[str] = Field(None, description='service mesh for performance test')
    name: Optional[str] = Field(None, description='name of performance test')
    qps: Optional[int] = Field(None, description='qps in number')
    t: Optional[int] = Field(None, description='time in integer e.g. 30')
    url: Optional[str] = Field(None, description='url for test')
    uuid: Optional[UUID] = Field(None, description='test-id of pre-existing test')


class PluginConfigArgs(BaseModel):
    Description: str = Field(..., description='description')
    Name: str = Field(..., description='name')
    Settable: List[str] = Field(..., description='settable')
    Value: List[str] = Field(..., description='value')


class PluginConfigNetwork(BaseModel):
    Type: str = Field(..., description='type')


class PluginConfigRootfs(BaseModel):
    diff_ids: Optional[List[str]] = Field(None, description='diff ids')
    type: Optional[str] = Field(None, description='type')


class PluginConfigUser(BaseModel):
    GID: Optional[int] = Field(None, description='g ID')
    UID: Optional[int] = Field(None, description='UID')


class PluginDevice(BaseModel):
    Description: str = Field(..., description='description')
    Name: str = Field(..., description='name')
    Path: str = Field(..., description='path')
    Settable: List[str] = Field(..., description='settable')


class PluginEnv(BaseModel):
    Description: str = Field(..., description='description')
    Name: str = Field(..., description='name')
    Settable: List[str] = Field(..., description='settable')
    Value: str = Field(..., description='value')


class PluginInterfaceType(BaseModel):
    Capability: str = Field(..., description='capability')
    Prefix: str = Field(..., description='prefix')
    Version: str = Field(..., description='version')


class PluginMount(BaseModel):
    Description: str = Field(..., description='description')
    Destination: str = Field(..., description='destination')
    Name: str = Field(..., description='name')
    Options: List[str] = Field(..., description='options')
    Settable: List[str] = Field(..., description='settable')
    Source: str = Field(..., description='source')
    Type: str = Field(..., description='type')


class PluginSettings(BaseModel):
    Args: List[str] = Field(..., description='args')
    Devices: List[PluginDevice] = Field(..., description='devices')
    Env: List[str] = Field(..., description='env')
    Mounts: List[PluginMount] = Field(..., description='mounts')


class Port(BaseModel):
    IP: Optional[str] = Field(
        None, description="Host IP address that the container's port is mapped to"
    )
    PrivatePort: int = Field(..., description='Port on the container')
    PublicPort: Optional[int] = Field(None, description='Port exposed on the host')
    Type: str = Field(..., description='type')


class PreferenceParams(BaseModel):
    anonymousPerfResults: Optional[bool] = None
    anonymousUsageStats: Optional[bool] = None


class Protocol(RootModel[str]):
    root: str = Field(
        ...,
        title='Protocol defines network protocols supported for things like container ports.',
    )


class ProviderType(RootModel[str]):
    root: str = Field(..., description='ProviderType - for representing provider types')


class RangeMap(BaseModel):
    from_: Optional[str] = Field(None, alias='from')
    text: Optional[str] = None
    to: Optional[str] = None


class Percentile(BaseModel):
    Percentile: Optional[float] = None
    Value: Optional[float] = None


class DurationHistogram(BaseModel):
    Avg: Optional[float] = None
    Max: Optional[float] = None
    Min: Optional[float] = None
    Percentiles: Optional[List[Percentile]] = None


class RunnerResults(BaseModel):
    ActualDuration: Optional[int] = None
    ActualQPS: Optional[float] = None
    DurationHistogram_1: Optional[DurationHistogram] = Field(
        None, alias='DurationHistogram'
    )
    StartTime: Optional[datetime] = None
    URL: Optional[str] = None
    load_generator: Optional[str] = Field(None, alias='load-generator')


class SeriesOverride(BaseModel):
    alias: Optional[str] = None
    bars: Optional[bool] = None
    color: Optional[str] = None
    dashes: Optional[bool] = None
    fill: Optional[int] = None
    fillBelowTo: Optional[str] = None
    legend: Optional[bool] = None
    lines: Optional[bool] = None
    linewidth: Optional[int] = None
    nullPointMode: Optional[str] = None
    stack: Optional[BoolString] = None
    transform: Optional[str] = None
    yaxis: Optional[int] = None
    zindex: Optional[int] = None


class ServiceAffinity(RootModel[str]):
    root: str = Field(..., description='Session Affinity Type string')


class ServiceExternalTrafficPolicyType(RootModel[str]):
    root: str = Field(..., description='Service External Traffic Policy Type string')


class ServiceStatus(BaseModel):
    loadBalancer: Optional[LoadBalancerStatus] = None


class ServiceType(RootModel[str]):
    root: str = Field(
        ..., description='Service Type string describes ingress methods for a service'
    )


class ServiceUpdateResponse(BaseModel):
    Warnings: Optional[List[str]] = Field(None, description='Optional warning messages')


class SessionAffinityConfig(BaseModel):
    clientIP: Optional[ClientIPConfig] = None


class Sort(BaseModel):
    col: Optional[int] = None
    desc: Optional[bool] = None


class SparkLine(BaseModel):
    fillColor: Optional[str] = None
    full: Optional[bool] = None
    lineColor: Optional[str] = None
    show: Optional[bool] = None
    ymax: Optional[float] = None
    ymin: Optional[float] = None


class StackdriverAlignOption(BaseModel):
    label: Optional[str] = None
    metricKinds: Optional[List[str]] = None
    text: Optional[str] = None
    value: Optional[str] = None
    valueTypes: Optional[List[str]] = None


class StackdriverAlignOptions(BaseModel):
    expanded: Optional[bool] = None
    label: Optional[str] = None
    options: Optional[List[StackdriverAlignOption]] = None


class StringArray(RootModel[List[str]]):
    root: List[str] = Field(
        ...,
        title='StringArray represents a one-dimensional array of the PostgreSQL character types.',
    )


class SupportedOperation(BaseModel):
    category: Optional[OpCategory] = None
    key: Optional[str] = None
    value: Optional[str] = None


class Settings(BaseModel):
    interval: Optional[str] = None
    min_doc_count: Optional[Dict[str, Any]] = None
    order: Optional[str] = None
    orderBy: Optional[str] = None
    size: Optional[str] = None


class BucketAgg(BaseModel):
    field: Optional[str] = None
    id: Optional[str] = None
    settings: Optional[Settings] = None
    type: Optional[str] = None


class GroupItem(BaseModel):
    params: Optional[List[str]] = None
    type: Optional[str] = None


class Metric(BaseModel):
    field: Optional[str] = None
    id: Optional[str] = None
    type: Optional[str] = None


class SelectItem(BaseModel):
    params: Optional[List[str]] = None
    type: Optional[str] = None


class WhereItem(BaseModel):
    datatype: Optional[str] = None
    name: Optional[str] = None
    params: Optional[List[str]] = None
    type: Optional[str] = None


class Target(BaseModel):
    alias: Optional[str] = None
    aliasBy: Optional[str] = None
    alignOptions: Optional[List[StackdriverAlignOptions]] = None
    alignmentPeriod: Optional[str] = None
    bucketAggs: Optional[List[BucketAgg]] = None
    crossSeriesReducer: Optional[str] = None
    datasource: Optional[str] = None
    dimensions: Optional[Dict[str, str]] = None
    dsType: Optional[str] = Field(None, description='For Elasticsearch')
    expr: Optional[str] = Field(None, description='For Prometheus')
    filters: Optional[List[str]] = None
    format: Optional[str] = None
    group: Optional[List[GroupItem]] = None
    groupBys: Optional[List[str]] = None
    hide: Optional[bool] = None
    instant: Optional[bool] = None
    interval: Optional[str] = None
    intervalFactor: Optional[int] = None
    legendFormat: Optional[str] = None
    measurement: Optional[str] = Field(None, description='For InfluxDB')
    metricColumn: Optional[str] = None
    metricKind: Optional[str] = None
    metricName: Optional[str] = None
    metricType: Optional[str] = None
    metrics: Optional[List[Metric]] = None
    namespace: Optional[str] = Field(None, description='For CloudWatch')
    perSeriesAligner: Optional[str] = None
    period: Optional[str] = None
    projectName: Optional[str] = Field(
        None,
        description='For the Stackdriver data source. Find out more information at\nhttps:/grafana.com/docs/grafana/v6.0/features/datasources/stackdriver/',
    )
    query: Optional[str] = None
    rawQuery: Optional[bool] = None
    rawSql: Optional[str] = None
    refId: Optional[str] = None
    region: Optional[str] = None
    select: Optional[List[List[SelectItem]]] = None
    statistics: Optional[List[str]] = None
    step: Optional[int] = None
    table: Optional[str] = Field(None, description='For PostgreSQL')
    target: Optional[str] = Field(None, description='For Graphite')
    timeColumn: Optional[str] = None
    timeField: Optional[str] = None
    valueType: Optional[str] = None
    where: Optional[List[WhereItem]] = None


class ThresholdModel(BaseModel):
    colorMode: Optional[str] = Field(None, description='critical, warning, ok, custom')
    fill: Optional[bool] = None
    fillColor: Optional[str] = Field(
        None,
        description='hexadecimal color (e.g. #629e51, only when ColorMode is "custom")',
    )
    line: Optional[bool] = None
    lineColor: Optional[str] = Field(
        None,
        description='hexadecimal color (e.g. #629e51, only when ColorMode is "custom")',
    )
    op: Optional[str] = Field(None, description='gt or lt')
    value: Optional[float] = Field(
        None,
        description='the alert threshold value, we do not omitempty, since 0 is a valid\nthreshold',
    )
    yaxis: Optional[str] = Field(None, description='left or right')


class Time(BaseModel):
    pass


class Tooltip(BaseModel):
    msResolution: Optional[bool] = None
    shared: Optional[bool] = None
    sort: Optional[int] = None
    value_type: Optional[str] = None


class Type(RootModel[int]):
    root: int = Field(..., title='Type represents the stored type of IntOrString.')


class UID(RootModel[str]):
    root: str = Field(
        ...,
        description="UID is a type that holds unique ID values, including UUIDs.  Because we\ndon't ONLY use UUIDs, this is an alias to string.  Being a type captures\nintent and helps make sure that UIDs and names do not get conflated.",
    )


class UUIDModel(RootModel[List[int]]):
    root: List[int] = Field(
        ...,
        title='UUID is an array type to represent the value of a UUID, as defined in RFC-4122.',
    )


class UserPrefsExtension(BaseModel):
    component: Optional[str] = None


class UserPrefsExtensions(RootModel[List[UserPrefsExtension]]):
    root: List[UserPrefsExtension] = Field(
        ..., description='UserPrefsExtensions is a collection of UserPrefsExtension'
    )


class ValueMap(BaseModel):
    op: Optional[str] = None
    text: Optional[str] = None
    value: Optional[str] = None


class Version(BaseModel):
    build: Optional[str] = None
    commitsha: Optional[str] = None
    latest: Optional[str] = None
    outdated: Optional[bool] = None
    release_channel: Optional[str] = None


class VolumeCreateBody(BaseModel):
    Driver: str = Field(..., description='Name of the volume driver to use.')
    DriverOpts: Dict[str, str] = Field(
        ...,
        description='A mapping of driver options and values. These options are passed directly to the driver and are driver specific.',
    )
    Labels: Dict[str, str] = Field(..., description='User-defined key/value metadata.')
    Name: str = Field(
        ...,
        description="The new volume's name. If not specified, Docker generates a name.",
    )


class VolumeUsageData(BaseModel):
    RefCount: int = Field(
        ...,
        description='The number of containers referencing this volume. This field\nis set to `-1` if the reference-count is not available.',
    )
    Size: int = Field(
        ...,
        description='Amount of disk space used by the volume (in bytes). This information\nis only available for volumes created with the `"local"` volume\ndriver. For volumes created with other volume drivers, this field\nis set to `-1` ("not available")',
    )


class ApiApplicationDeployPostRequest(BaseModel):
    Upload_Yaml_Yml_File: Optional[bytes] = Field(None, alias='Upload Yaml/Yml File')


class ApiPatternDeployPostRequest(BaseModel):
    Upload_Yaml_Yml_File: Optional[bytes] = Field(None, alias='Upload Yaml/Yml File')


class ApiSystemKubernetesContextsPostResponse(RootModel[List[K8SContext]]):
    root: List[K8SContext]


class Adapter(BaseModel):
    adapter_location: Optional[str] = None
    git_commit_sha: Optional[str] = None
    name: Optional[str] = None
    ops: Optional[List[SupportedOperation]] = None
    version: Optional[str] = None


class AlertCondition(BaseModel):
    evaluator: Optional[AlertEvaluator] = None
    operator: Optional[AlertOperator] = None
    query: Optional[AlertQuery] = None
    reducer: Optional[AlertReducer] = None
    type: Optional[str] = None


class Axis(BaseModel):
    decimals: Optional[int] = None
    format: Optional[str] = None
    label: Optional[str] = None
    logBase: Optional[int] = None
    max: Optional[FloatString] = None
    min: Optional[FloatString] = None
    show: Optional[bool] = None


class Capability(BaseModel):
    endpoint: Optional[str] = None
    feature: Optional[Feature] = None


class ColumnStyle(BaseModel):
    alias: Optional[str] = None
    colorMode: Optional[str] = None
    colors: Optional[List[str]] = None
    dateFormat: Optional[str] = None
    decimals: Optional[int] = None
    link: Optional[bool] = None
    linkTargetBlank: Optional[bool] = None
    linkTooltip: Optional[str] = None
    linkUrl: Optional[str] = None
    mappingType: Optional[int] = None
    pattern: Optional[str] = None
    thresholds: Optional[List[str]] = None
    type: Optional[str] = None
    unit: Optional[str] = None
    valueMaps: Optional[List[ValueMap]] = None


class ContainerWaitOKBody(BaseModel):
    Error: ContainerWaitOKBodyError
    StatusCode: int = Field(..., description='Exit code of the container')


class IntOrString(BaseModel):
    IntVal: Optional[int] = None
    StrVal: Optional[str] = None
    Type_1: Optional[Type] = Field(None, alias='Type')


class K8SConfig(BaseModel):
    clusterConfigured: Optional[bool] = None
    config: Optional[List[int]] = None
    configuredServer: Optional[str] = None
    contextName: Optional[str] = None
    inClusterConfig: Optional[bool] = None
    k8sfile: Optional[str] = None
    nodes: Optional[List[K8SNode]] = None
    server_version: Optional[str] = None


class ManagedFieldsEntry(BaseModel):
    apiVersion: Optional[str] = Field(
        None,
        description='APIVersion defines the version of this resource that this field set\napplies to. The format is "group/version" just like the top-level\nAPIVersion field. It is necessary to track the version of a field\nset because it cannot be automatically converted.',
    )
    fieldsType: Optional[str] = Field(
        None,
        description='FieldsType is the discriminator for the different fields format and version.\nThere is currently only one possible value: "FieldsV1"',
    )
    fieldsV1: Optional[FieldsV1] = None
    manager: Optional[str] = Field(
        None,
        description='Manager is an identifier of the workflow managing these fields.',
    )
    operation: Optional[ManagedFieldsOperationType] = None
    time: Optional[Time] = None


class MesheryApplication(BaseModel):
    application_file: Optional[str] = None
    created_at: Optional[datetime] = None
    id: Optional[UUIDModel] = None
    location: Optional[Map] = None
    name: Optional[str] = None
    updated_at: Optional[datetime] = None
    user_id: Optional[str] = Field(
        None,
        description="Meshery doesn't have the user id fields\nbut the remote provider is allowed to provide one",
    )


class MesheryFilter(BaseModel):
    created_at: Optional[datetime] = None
    filter_file: Optional[str] = None
    id: Optional[UUIDModel] = None
    location: Optional[Map] = None
    name: Optional[str] = None
    updated_at: Optional[datetime] = None
    user_id: Optional[str] = Field(
        None,
        description="Meshery doesn't have the user id fields\nbut the remote provider is allowed to provide one",
    )


class MesheryPattern(BaseModel):
    created_at: Optional[datetime] = None
    id: Optional[UUIDModel] = None
    location: Optional[Map] = None
    name: Optional[str] = None
    pattern_file: Optional[str] = None
    updated_at: Optional[datetime] = None
    user_id: Optional[str] = Field(
        None,
        description="Meshery doesn't have the user id fields\nbut the remote provider is allowed to provide one",
    )


class OwnerReference(BaseModel):
    apiVersion: Optional[str] = Field(None, description='API version of the referent.')
    blockOwnerDeletion: Optional[bool] = Field(
        None,
        description='If true, AND if the owner has the "foregroundDeletion" finalizer, then\nthe owner cannot be deleted from the key-value store until this\nreference is removed.\nDefaults to false.\nTo set this field, a user needs "delete" permission of the owner,\notherwise 422 (Unprocessable Entity) will be returned.\n+optional',
    )
    controller: Optional[bool] = Field(
        None,
        description='If true, this reference points to the managing controller.\n+optional',
    )
    kind: Optional[str] = Field(
        None,
        description='Kind of the referent.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    name: Optional[str] = Field(
        None,
        description='Name of the referent.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#names',
    )
    uid: Optional[UID] = None


class PatternsAPIResponse(BaseModel):
    page: Optional[int] = None
    page_size: Optional[int] = None
    patterns: Optional[List[MesheryPattern]] = None
    total_count: Optional[int] = None


class PerformanceProfile(BaseModel):
    concurrent_request: Optional[int] = None
    content_type: Optional[str] = None
    created_at: Optional[Time] = None
    duration: Optional[str] = None
    endpoints: Optional[StringArray] = None
    id: Optional[UUIDModel] = None
    last_run: Optional[Time] = None
    load_generators: Optional[StringArray] = None
    name: Optional[str] = None
    qps: Optional[int] = None
    request_body: Optional[str] = None
    request_cookies: Optional[str] = None
    request_headers: Optional[str] = None
    schedule: Optional[UUIDModel] = None
    service_mesh: Optional[str] = None
    total_results: Optional[int] = None
    updated_at: Optional[Time] = None


class PerformanceProfilesAPIResponse(BaseModel):
    page: Optional[int] = None
    page_size: Optional[int] = None
    profiles: Optional[List[PerformanceProfile]] = None
    total_count: Optional[int] = None


class PerformanceResult(BaseModel):
    mesh: Optional[str] = None
    meshery_id: Optional[UUIDModel] = None
    name: Optional[str] = None
    performance_profile: Optional[UUIDModel] = None
    runner_results: Optional[RunnerResults] = None
    server_board_config: Optional[Dict[str, Any]] = None
    server_metrics: Optional[Dict[str, Any]] = None
    test_start_time: Optional[datetime] = None
    user_id: Optional[UUIDModel] = None


class PerformanceResultsAPIResponse(BaseModel):
    page: Optional[int] = None
    page_size: Optional[int] = None
    results: Optional[List[PerformanceResult]] = None
    total_count: Optional[int] = None


class PerformanceTestConfigClient(BaseModel):
    body: Optional[str] = None
    connections: Optional[int] = None
    content_type: Optional[str] = None
    cookies: Optional[Dict[str, str]] = None
    endpoint_urls: Optional[List[str]] = None
    headers: Optional[Dict[str, str]] = None
    internal: Optional[bool] = None
    load_generator: Optional[str] = None
    protocol: Optional[PerformanceTestConfigClientProtocol] = None
    rps: Optional[int] = None


class PluginConfigInterface(BaseModel):
    ProtocolScheme: Optional[str] = Field(
        None, description='Protocol to use for clients connecting to the plugin.'
    )
    Socket: str = Field(..., description='socket')
    Types: List[PluginInterfaceType] = Field(..., description='types')


class PluginConfigLinux(BaseModel):
    AllowAllDevices: bool = Field(..., description='allow all devices')
    Capabilities: List[str] = Field(..., description='capabilities')
    Devices: List[PluginDevice] = Field(..., description='devices')


class Schedule(BaseModel):
    cron_expression: Optional[str] = Field(
        None,
        description='CronExpression is the UNIX cron expression (quartz expression)',
    )
    id: Optional[UUIDModel] = None


class SchedulesAPIResponse(BaseModel):
    page: Optional[int] = None
    page_size: Optional[int] = None
    schedules: Optional[List[Schedule]] = None
    total_count: Optional[int] = None


class ServicePort(BaseModel):
    appProtocol: Optional[str] = Field(
        None,
        description='The application protocol for this port.\nThis field follows standard Kubernetes label syntax.\nUn-prefixed names are reserved for IANA standard service names (as per\nRFC-6335 and http://www.iana.org/assignments/service-names).\nNon-standard protocols should use prefixed names such as\nmycompany.com/my-custom-protocol.\nField can be enabled with ServiceAppProtocol feature gate.\n+optional',
    )
    name: Optional[str] = Field(
        None,
        description="The name of this port within the service. This must be a DNS_LABEL.\nAll ports within a ServiceSpec must have unique names. When considering\nthe endpoints for a Service, this must match the 'name' field in the\nEndpointPort.\nOptional if only one ServicePort is defined on this service.\n+optional",
    )
    nodePort: Optional[int] = Field(
        None,
        description='The port on each node on which this service is exposed when type=NodePort or LoadBalancer.\nUsually assigned by the system. If specified, it will be allocated to the service\nif unused or else creation of the service will fail.\nDefault is to auto-allocate a port if the ServiceType of this Service requires one.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport\n+optional',
    )
    port: Optional[int] = Field(
        None, description='The port that will be exposed by this service.'
    )
    protocol: Optional[Protocol] = None
    targetPort: Optional[IntOrString] = None


class ServiceSpec(BaseModel):
    clusterIP: Optional[str] = Field(
        None,
        description='clusterIP is the IP address of the service and is usually assigned\nrandomly by the master. If an address is specified manually and is not in\nuse by others, it will be allocated to the service; otherwise, creation\nof the service will fail. This field can not be changed through updates.\nValid values are "None", empty string (""), or a valid IP address. "None"\ncan be specified for headless services when proxying is not required.\nOnly applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if\ntype is ExternalName.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies\n+optional',
    )
    externalIPs: Optional[List[str]] = Field(
        None,
        description='externalIPs is a list of IP addresses for which nodes in the cluster\nwill also accept traffic for this service.  These IPs are not managed by\nKubernetes.  The user is responsible for ensuring that traffic arrives\nat a node with this IP.  A common example is external load-balancers\nthat are not part of the Kubernetes system.\n+optional',
    )
    externalName: Optional[str] = Field(
        None,
        description='externalName is the external reference that kubedns or equivalent will\nreturn as a CNAME record for this service. No proxying will be involved.\nMust be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123)\nand requires Type to be ExternalName.\n+optional',
    )
    externalTrafficPolicy: Optional[ServiceExternalTrafficPolicyType] = None
    healthCheckNodePort: Optional[int] = Field(
        None,
        description='healthCheckNodePort specifies the healthcheck nodePort for the service.\nIf not specified, HealthCheckNodePort is created by the service api\nbackend with the allocated nodePort. Will use user-specified nodePort value\nif specified by the client. Only effects when Type is set to LoadBalancer\nand ExternalTrafficPolicy is set to Local.\n+optional',
    )
    ipFamily: Optional[IPFamily] = None
    loadBalancerIP: Optional[str] = Field(
        None,
        description='Only applies to Service Type: LoadBalancer\nLoadBalancer will get created with the IP specified in this field.\nThis feature depends on whether the underlying cloud-provider supports specifying\nthe loadBalancerIP when a load balancer is created.\nThis field will be ignored if the cloud-provider does not support the feature.\n+optional',
    )
    loadBalancerSourceRanges: Optional[List[str]] = Field(
        None,
        description='If specified and supported by the platform, this will restrict traffic through the cloud-provider\nload-balancer will be restricted to the specified client IPs. This field will be ignored if the\ncloud-provider does not support the feature."\nMore info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/\n+optional',
    )
    ports: Optional[List[ServicePort]] = Field(
        None,
        description='The list of ports that are exposed by this service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies\n+patchMergeKey=port\n+patchStrategy=merge\n+listType=map\n+listMapKey=port\n+listMapKey=protocol',
    )
    publishNotReadyAddresses: Optional[bool] = Field(
        None,
        description="publishNotReadyAddresses, when set to true, indicates that DNS implementations\nmust publish the notReadyAddresses of subsets for the Endpoints associated with\nthe Service. The default value is false.\nThe primary use case for setting this field is to use a StatefulSet's Headless Service\nto propagate SRV records for its Pods without respect to their readiness for purpose\nof peer discovery.\n+optional",
    )
    selector: Optional[Dict[str, str]] = Field(
        None,
        description='Route service traffic to pods with label keys and values matching this\nselector. If empty or not present, the service is assumed to have an\nexternal process managing its endpoints, which Kubernetes will not\nmodify. Only applies to types ClusterIP, NodePort, and LoadBalancer.\nIgnored if type is ExternalName.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/\n+optional',
    )
    sessionAffinity: Optional[ServiceAffinity] = None
    sessionAffinityConfig: Optional[SessionAffinityConfig] = None
    topologyKeys: Optional[List[str]] = Field(
        None,
        description='topologyKeys is a preference-order list of topology keys which\nimplementations of services should use to preferentially sort endpoints\nwhen accessing this Service, it can not be used at the same time as\nexternalTrafficPolicy=Local.\nTopology keys must be valid label keys and at most 16 keys may be specified.\nEndpoints are chosen based on the first topology key with available backends.\nIf this field is specified and all entries have no backends that match\nthe topology of the client, the service has no backends for that client\nand connections should fail.\nThe special value "*" may be used to mean "any topology". This catch-all\nvalue, if used, only makes sense as the last value in the list.\nIf this is not specified or empty, no topology constraints will be applied.\n+optional',
    )
    type: Optional[ServiceType] = None


class Volume(BaseModel):
    CreatedAt: Optional[str] = Field(
        None, description='Date/Time the volume was created.'
    )
    Driver: str = Field(
        ..., description='Name of the volume driver used by the volume.'
    )
    Labels: Dict[str, str] = Field(..., description='User-defined key/value metadata.')
    Mountpoint: str = Field(..., description='Mount path of the volume on the host.')
    Name: str = Field(..., description='Name of the volume.')
    Options: Dict[str, str] = Field(
        ..., description='The driver specific options used when creating the volume.'
    )
    Scope: str = Field(
        ...,
        description='The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.',
    )
    Status: Optional[Dict[str, Dict[str, Any]]] = Field(
        None,
        description='Low-level details about the volume, provided by the volume driver.\nDetails are returned as a map with key/value pairs:\n`{"key":"value","key2":"value2"}`.\n\nThe `Status` field is optional, and is omitted if the volume driver\ndoes not support this feature.',
    )
    UsageData: Optional[VolumeUsageData] = None


class VolumeListOKBody(BaseModel):
    Volumes: List[Volume] = Field(..., description='List of volumes')
    Warnings: List[str] = Field(
        ..., description='Warnings that occurred when fetching the list of volumes'
    )


class ApiSystemAdapterManagePostResponse(RootModel[List[Adapter]]):
    root: List[Adapter]


class ApiSystemAdaptersGetResponse(RootModel[List[Adapter]]):
    root: List[Adapter]


class Alert(BaseModel):
    alertRuleTags: Optional[Dict[str, str]] = None
    conditions: Optional[List[AlertCondition]] = None
    executionErrorState: Optional[str] = None
    for_: Optional[str] = Field(None, alias='for')
    frequency: Optional[str] = None
    handler: Optional[int] = None
    message: Optional[str] = None
    name: Optional[str] = None
    noDataState: Optional[str] = None
    notifications: Optional[List[AlertNotification]] = None


class ApplicationsAPIResponse(BaseModel):
    applications: Optional[List[MesheryApplication]] = None
    page: Optional[int] = None
    page_size: Optional[int] = None
    total_count: Optional[int] = None


class Capabilities(RootModel[List[Capability]]):
    root: List[Capability] = Field(
        ..., description='Capabilities is the collection of capability'
    )


class FiltersAPIResponse(BaseModel):
    filters: Optional[List[MesheryFilter]] = None
    page: Optional[int] = None
    page_size: Optional[int] = None
    total_count: Optional[int] = None


class Panel(BaseModel):
    alert: Optional[Alert] = None
    aliasColors: Optional[Dict[str, Any]] = None
    bars: Optional[bool] = None
    cards: Optional[Cards] = None
    collapsed: Optional[bool] = None
    color: Optional[Color] = None
    colorBackground: Optional[bool] = None
    colorValue: Optional[bool] = None
    colors: Optional[List[str]] = None
    columns: Optional[List[Column]] = None
    content: Optional[str] = None
    dashLength: Optional[int] = None
    dashboardTags: Optional[List[str]] = None
    dashes: Optional[bool] = None
    dataFormat: Optional[str] = None
    datasource: Optional[str] = None
    decimals: Optional[int] = None
    description: Optional[str] = None
    editable: Optional[bool] = None
    error: Optional[bool] = None
    fieldConfig: Optional[FieldConfig] = None
    fill: Optional[int] = None
    folderId: Optional[int] = None
    format: Optional[str] = None
    gauge: Optional[Gauge] = None
    gridPos: Optional[GridPos] = None
    headings: Optional[bool] = None
    height: Optional[Dict[str, Any]] = None
    hideTimeOverride: Optional[bool] = None
    hideZeroBuckets: Optional[bool] = None
    highlightCards: Optional[bool] = None
    id: Optional[int] = None
    isNew: Optional[bool] = None
    leftYAxisLabel: Optional[str] = None
    legend: Optional[Legend] = None
    limit: Optional[int] = None
    lines: Optional[bool] = None
    linewidth: Optional[int] = None
    links: Optional[List[Link]] = None
    mappingType: Optional[int] = None
    mappingTypes: Optional[List[MapType]] = None
    maxDataPoints: Optional[IntString] = None
    minSpan: Optional[float] = None
    mode: Optional[str] = None
    nameFilter: Optional[str] = None
    nullPointMode: Optional[str] = None
    onlyAlertsOnDashboard: Optional[bool] = None
    options: Optional[Options] = None
    pageSize: Optional[int] = None
    panels: Optional[List[Panel]] = None
    percentage: Optional[bool] = None
    pointradius: Optional[float] = None
    points: Optional[bool] = None
    postfix: Optional[str] = None
    postfixFontSize: Optional[str] = None
    prefix: Optional[str] = None
    prefixFontSize: Optional[str] = None
    query: Optional[str] = None
    rangeMaps: Optional[List[RangeMap]] = None
    recent: Optional[bool] = None
    renderer: Optional[str] = None
    repeat: Optional[str] = None
    repeatPanelId: Optional[int] = Field(
        None, description='RepeatIteration *int64   `json:"repeatIteration,omitempty"`'
    )
    reverseYBuckets: Optional[bool] = None
    rightYAxisLabel: Optional[str] = None
    scopedVars: Optional[Dict[str, ScopedVars]] = None
    scroll: Optional[bool] = None
    search: Optional[bool] = None
    seriesOverrides: Optional[List[SeriesOverride]] = None
    show: Optional[str] = None
    showHeader: Optional[bool] = None
    sort: Optional[Sort] = None
    sortOrder: Optional[int] = None
    spaceLength: Optional[int] = None
    span: Optional[float] = None
    sparkline: Optional[SparkLine] = None
    stack: Optional[bool] = None
    starred: Optional[bool] = None
    stateFilter: Optional[List[str]] = None
    steppedLine: Optional[bool] = None
    styles: Optional[List[ColumnStyle]] = None
    tags: Optional[List[str]] = None
    targets: Optional[List[Target]] = None
    thresholds: Optional[List[ThresholdModel]] = None
    timeFrom: Optional[str] = None
    timeShift: Optional[str] = None
    title: Optional[str] = None
    tooltip: Optional[Tooltip] = None
    tooltipDecimals: Optional[int] = None
    transform: Optional[str] = None
    transparent: Optional[bool] = None
    type: Optional[str] = None
    valueFontSize: Optional[str] = None
    valueMaps: Optional[List[ValueMap]] = None
    valueName: Optional[str] = None
    x_axis: Optional[bool] = Field(None, alias='x-axis')
    xAxis: Optional[XAxis] = None
    xBucketNumber: Optional[float] = None
    xBucketSize: Optional[str] = None
    xaxis: Optional[Axis] = None
    y_axis: Optional[bool] = Field(None, alias='y-axis')
    yAxis: Optional[YAxis] = None
    yBucketBound: Optional[str] = None
    yBucketNumber: Optional[float] = None
    yBucketSize: Optional[float] = None
    y_formats: Optional[List[str]] = None
    yaxes: Optional[List[Axis]] = None


class PerformanceTestConfig(BaseModel):
    clients: Optional[List[PerformanceTestConfigClient]] = Field(
        None, description='Single or distributed load generators'
    )
    duration: Optional[str] = Field(
        None, description='Length of time the endpoint will be under load'
    )
    id: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    smp_version: Optional[str] = Field(None, description='Spec version')


class PluginConfig(BaseModel):
    Args: PluginConfigArgs
    Description: str = Field(..., description='description')
    DockerVersion: Optional[str] = Field(
        None, description='Docker Version used to create the plugin'
    )
    Documentation: str = Field(..., description='documentation')
    Entrypoint: List[str] = Field(..., description='entrypoint')
    Env: List[PluginEnv] = Field(..., description='env')
    Interface: PluginConfigInterface
    IpcHost: bool = Field(..., description='ipc host')
    Linux: PluginConfigLinux
    Mounts: List[PluginMount] = Field(..., description='mounts')
    Network: PluginConfigNetwork
    PidHost: bool = Field(..., description='pid host')
    PropagatedMount: str = Field(..., description='propagated mount')
    User: Optional[PluginConfigUser] = None
    WorkDir: str = Field(..., description='work dir')
    rootfs: Optional[PluginConfigRootfs] = None


class Service(BaseModel):
    annotations: Optional[Dict[str, str]] = Field(
        None,
        description='Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: http://kubernetes.io/docs/user-guide/annotations\n+optional',
    )
    apiVersion: Optional[str] = Field(
        None,
        description='APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n+optional',
    )
    clusterName: Optional[str] = Field(
        None,
        description='The name of the cluster which the object belongs to.\nThis is used to distinguish resources with same name and namespace in different clusters.\nThis field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.\n+optional',
    )
    creationTimestamp: Optional[Time] = None
    deletionGracePeriodSeconds: Optional[int] = Field(
        None,
        description='Number of seconds allowed for this object to gracefully terminate before\nit will be removed from the system. Only set when deletionTimestamp is also set.\nMay only be shortened.\nRead-only.\n+optional',
    )
    deletionTimestamp: Optional[Time] = None
    finalizers: Optional[List[str]] = Field(
        None,
        description='Must be empty before the object is deleted from the registry. Each entry\nis an identifier for the responsible component that will remove the entry\nfrom the list. If the deletionTimestamp of the object is non-nil, entries\nin this list can only be removed.\nFinalizers may be processed and removed in any order.  Order is NOT enforced\nbecause it introduces significant risk of stuck finalizers.\nfinalizers is a shared field, any actor with permission can reorder it.\nIf the finalizer list is processed in order, then this can lead to a situation\nin which the component responsible for the first finalizer in the list is\nwaiting for a signal (field value, external system, or other) produced by a\ncomponent responsible for a finalizer later in the list, resulting in a deadlock.\nWithout enforced ordering finalizers are free to order amongst themselves and\nare not vulnerable to ordering changes in the list.\n+optional\n+patchStrategy=merge',
    )
    generateName: Optional[str] = Field(
        None,
        description='GenerateName is an optional prefix, used by the server, to generate a unique\nname ONLY IF the Name field has not been provided.\nIf this field is used, the name returned to the client will be different\nthan the name passed. This value will also be combined with a unique suffix.\nThe provided value has the same validation rules as the Name field,\nand may be truncated by the length of the suffix required to make the value\nunique on the server.\n\nIf this field is specified and the generated name exists, the server will\nNOT return a 409 - instead, it will either return 201 Created or 500 with Reason\nServerTimeout indicating a unique name could not be found in the time allotted, and the client\nshould retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency\n+optional',
    )
    generation: Optional[int] = Field(
        None,
        description='A sequence number representing a specific generation of the desired state.\nPopulated by the system. Read-only.\n+optional',
    )
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n+optional',
    )
    labels: Optional[Dict[str, str]] = Field(
        None,
        description='Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: http://kubernetes.io/docs/user-guide/labels\n+optional',
    )
    managedFields: Optional[List[ManagedFieldsEntry]] = Field(
        None,
        description='ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that workflow. This is mostly for internal\nhousekeeping, and users typically shouldn\'t need to set or\nunderstand this field. A workflow can be the user\'s name, a\ncontroller\'s name, or the name of a specific apply path like\n"ci-cd". The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional',
    )
    name: Optional[str] = Field(
        None,
        description='Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#names\n+optional',
    )
    namespace: Optional[str] = Field(
        None,
        description='Namespace defines the space within each name must be unique. An empty namespace is\nequivalent to the "default" namespace, but "default" is the canonical representation.\nNot all objects are required to be scoped to a namespace - the value of this field for\nthose objects will be empty.\n\nMust be a DNS_LABEL.\nCannot be updated.\nMore info: http://kubernetes.io/docs/user-guide/namespaces\n+optional',
    )
    ownerReferences: Optional[List[OwnerReference]] = Field(
        None,
        description='List of objects depended by this object. If ALL objects in the list have\nbeen deleted, this object will be garbage collected. If this object is managed by a controller,\nthen an entry in this list will point to this controller, with the controller field set to true.\nThere cannot be more than one managing controller.\n+optional\n+patchMergeKey=uid\n+patchStrategy=merge',
    )
    resourceVersion: Optional[str] = Field(
        None,
        description='An opaque value that represents the internal version of this object that can\nbe used by clients to determine when objects have changed. May be used for optimistic\nconcurrency, change detection, and the watch operation on a resource or set of resources.\nClients must treat these values as opaque and passed unmodified back to the server.\nThey may only be valid for a particular resource or set of resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and .\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional',
    )
    selfLink: Optional[str] = Field(
        None,
        description='SelfLink is a URL representing this object.\nPopulated by the system.\nRead-only.\n\nDEPRECATED\nKubernetes will stop propagating this field in 1.20 release and the field is planned\nto be removed in 1.21 release.\n+optional',
    )
    spec: Optional[ServiceSpec] = None
    status: Optional[ServiceStatus] = None
    uid: Optional[UID] = None


class ApiSystemMeshsyncGrafanaGetResponse(
    RootModel[Optional[Dict[str, List[Service]]]]
):
    root: Optional[Dict[str, List[Service]]] = None


class ApiSystemMeshsyncPrometheusGetResponse(
    RootModel[Optional[Dict[str, List[Service]]]]
):
    root: Optional[Dict[str, List[Service]]] = None


class ApiTelemetryMetricsGrafanaScanGetResponse(
    RootModel[Optional[Dict[str, List[Service]]]]
):
    root: Optional[Dict[str, List[Service]]] = None


class GrafanaBoard(BaseModel):
    org_id: Optional[int] = None
    panels: Optional[List[Panel]] = None
    slug: Optional[str] = None
    template_vars: Optional[List[GrafanaTemplateVars]] = None
    title: Optional[str] = None
    uid: Optional[str] = None
    uri: Optional[str] = None


class Plugin(BaseModel):
    Config: PluginConfig
    Enabled: bool = Field(
        ...,
        description='True if the plugin is running. False if the plugin is not running, only installed.',
    )
    Id: Optional[str] = Field(None, description='Id')
    Name: str = Field(..., description='name')
    PluginReference: Optional[str] = Field(
        None, description='plugin remote reference used to push/pull the plugin'
    )
    Settings: PluginSettings


class SelectedGrafanaConfig(BaseModel):
    board: Optional[GrafanaBoard] = None
    panels: Optional[List[Panel]] = None
    templateVars: Optional[List[str]] = None


class ApiTelemetryMetricsBoardsPostRequest(RootModel[List[SelectedGrafanaConfig]]):
    root: List[SelectedGrafanaConfig]


class ApiTelemetryMetricsGrafanaBoardsGetResponse(RootModel[List[GrafanaBoard]]):
    root: List[GrafanaBoard]


class ApiTelemetryMetricsStaticBoardGetResponse(
    RootModel[Optional[Dict[str, GrafanaBoard]]]
):
    root: Optional[Dict[str, GrafanaBoard]] = None


class Grafana(BaseModel):
    grafanaAPIKey: Optional[str] = None
    grafanaURL: Optional[str] = None
    selectedBoardsConfigs: Optional[List[SelectedGrafanaConfig]] = Field(
        None,
        description='GrafanaBoardSearch string          `json:"grafanaBoardSearch,omitempty"`',
    )


class Prometheus(BaseModel):
    prometheusURL: Optional[str] = None
    selectedPrometheusBoardsConfigs: Optional[List[SelectedGrafanaConfig]] = None


class Preference(BaseModel):
    anonymousPerfResults: Optional[bool] = None
    anonymousUsageStats: Optional[bool] = None
    grafana: Optional[Grafana] = None
    k8sConfig: Optional[K8SConfig] = None
    loadTestPrefs: Optional[LoadTestPreferences] = None
    meshAdapters: Optional[List[Adapter]] = None
    prometheus: Optional[Prometheus] = None
    updated_at: Optional[datetime] = None


class Extensions(BaseModel):
    graphql: Optional[GraphQLExtensions] = None
    navigator: Optional[NavigatorExtensions] = None
    user_prefs: Optional[UserPrefsExtensions] = None


class NavigatorExtension(BaseModel):
    children: Optional[NavigatorExtensions] = None
    component: Optional[str] = None
    href: Optional[Href] = None
    icon: Optional[str] = None
    link: Optional[bool] = None
    show: Optional[bool] = None
    title: Optional[str] = None


class NavigatorExtensions(RootModel[List[NavigatorExtension]]):
    root: List[NavigatorExtension] = Field(
        ..., description='NavigatorExtensions is a collection of NavigatorExtension'
    )


class ProviderProperties(BaseModel):
    capabilities: Optional[Capabilities] = None
    extensions: Optional[Extensions] = None
    package_url: Optional[str] = None
    package_version: Optional[str] = None
    provider_description: Optional[List[str]] = None
    provider_name: Optional[str] = None
    provider_type: Optional[ProviderType] = None
    provider_url: Optional[str] = None


class ApiProvidersGetResponse(RootModel[Optional[Dict[str, ProviderProperties]]]):
    root: Optional[Dict[str, ProviderProperties]] = None


Panel.model_rebuild()
Extensions.model_rebuild()
NavigatorExtension.model_rebuild()
